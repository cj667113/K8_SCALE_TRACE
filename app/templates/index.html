<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scaleout Controller</title>
  <style>
    :root {
      --ink: #1d1713;
      --muted: #5a4e47;
      --accent: #0f6d5b;
      --accent-2: #e36d2f;
      --accent-3: #1f7dcf;
      --paper: #f7f1e7;
      --panel: rgba(255, 255, 255, 0.8);
      --shadow: 0 20px 60px rgba(17, 12, 8, 0.12);
      --glass: rgba(255, 255, 255, 0.6);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: "Avenir Next", "Futura", "Gill Sans", "Trebuchet MS", sans-serif;
      color: var(--ink);
      background: radial-gradient(circle at 20% 10%, #f4d6b8 0%, transparent 50%),
                  radial-gradient(circle at 80% 0%, #d7f0e4 0%, transparent 55%),
                  linear-gradient(135deg, #f7efe5 0%, #f0d5c3 45%, #e8f4ef 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 32px;
    }

    .shell {
      width: min(1200px, 95vw);
      display: grid;
      gap: 18px;
      animation: rise 0.7s ease-out;
    }

    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 18px;
      padding: 22px 26px;
      border-radius: 20px;
      background: var(--glass);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.6);
      box-shadow: var(--shadow);
    }

    .title {
      font-size: 30px;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }

    .subtitle {
      color: var(--muted);
      font-size: 14px;
      margin: 0;
    }

    .badge {
      background: rgba(15, 109, 91, 0.15);
      color: var(--accent);
      font-weight: 700;
      padding: 8px 14px;
      border-radius: 999px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.7px;
    }

    .panel {
      background: var(--panel);
      backdrop-filter: blur(12px);
      border-radius: 22px;
      padding: 22px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255, 255, 255, 0.6);
    }

    .tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 18px;
    }

    .tab {
      border: none;
      padding: 10px 16px;
      border-radius: 999px;
      background: rgba(31, 23, 19, 0.08);
      color: var(--muted);
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
    }

    .tab.active {
      background: linear-gradient(135deg, var(--accent), #1c8a73);
      color: #fff;
      transform: translateY(-1px);
    }

    .tab-panel {
      display: none;
      animation: fadeIn 0.3s ease-out;
    }

    .tab-panel.active {
      display: block;
    }


    .events-grid {
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 18px;
      align-items: start;
    }

    .events-grid .card {
      min-width: 0;
    }

    .grid-two {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 18px;
    }

    .card {
      background: rgba(255, 255, 255, 0.85);
      border-radius: 18px;
      padding: 18px;
      border: 1px solid rgba(15, 109, 91, 0.12);
      box-shadow: 0 12px 30px rgba(15, 109, 91, 0.08);
    }

    .card-title {
      font-weight: 700;
      margin-bottom: 12px;
      font-size: 16px;
    }

    .input-row {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    input[type=number], select {
      padding: 12px 14px;
      font-size: 16px;
      border-radius: 12px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: #fff;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    button.primary {
      padding: 12px 16px;
      border-radius: 14px;
      font-weight: 700;
      font-size: 16px;
      border: none;
      color: #fff;
      background: linear-gradient(135deg, var(--accent), #1c8a73);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
      box-shadow: 0 12px 22px rgba(15, 109, 91, 0.25);
    }

    button.primary:hover {
      transform: translateY(-1px);
    }

    button.ghost {
      padding: 12px 16px;
      border-radius: 14px;
      font-weight: 700;
      font-size: 16px;
      border: 2px solid var(--accent);
      color: var(--accent);
      background: transparent;
      cursor: pointer;
    }

    .meta {
      margin-top: 12px;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
    }

    .pill {
      display: inline-block;
      margin-right: 8px;
      margin-bottom: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(15, 109, 91, 0.12);
      color: var(--accent);
      font-size: 12px;
      font-weight: 600;
    }

    .log-box {
      background: #111714;
      color: #d7f9e8;
      border-radius: 18px;
      padding: 18px;
      height: 360px;
      overflow-y: auto;
      font-family: "Courier New", "Lucida Console", monospace;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
    }



    .event-tabs {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }

    .event-tab,
    .event-tabs .ghost {
      border: none;
      padding: 8px 14px;
      border-radius: 999px;
      background: rgba(31, 23, 19, 0.08);
      color: var(--muted);
      font-weight: 600;
      cursor: pointer;
      font-size: 12px;
      line-height: 1;
      min-height: 32px;
    }

    .event-tabs .ghost {
      background: transparent;
      border: 2px solid var(--accent);
      color: var(--accent);
      padding: 6px 14px;
    }

    .event-tab.active {
      background: linear-gradient(135deg, var(--accent), #1c8a73);
      color: #fff;
    }

    .table-wrap {
      max-height: 360px;
      overflow: auto;
      border-radius: 14px;
      border: 1px solid rgba(0, 0, 0, 0.08);
      background: #fff;
    }

    .event-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .event-table th,
    .event-table td {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.06);
      text-align: left;
      vertical-align: top;
    }

    .event-table thead {
      position: sticky;
      top: 0;
      background: #f6f3ef;
      z-index: 1;
    }

    .event-table tr:nth-child(even) td {
      background: rgba(15, 109, 91, 0.04);
    }

    .log-line {
      opacity: 1;
    }

    .summary-grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 12px;
    }

    .summary-card {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 16px;
      padding: 14px;
      border: 1px solid rgba(31, 125, 207, 0.15);
    }

    .summary-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      color: var(--muted);
    }

    .summary-value {
      font-size: 20px;
      font-weight: 700;
      margin-top: 8px;
      color: var(--ink);
    }

    .timeline {
      margin-top: 16px;
      padding: 14px;
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.75);
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .timeline-title {
      font-weight: 700;
      margin-bottom: 10px;
    }

    .timeline-item {
      font-size: 13px;
      margin-bottom: 6px;
      color: var(--muted);
    }

    .graph-wrap {
      display: grid;
      gap: 14px;
    }

    .graph-card {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 18px;
      padding: 16px;
      border: 1px solid rgba(15, 109, 91, 0.15);
    }

    canvas {
      width: 100%;
      height: 320px;
      border-radius: 12px;
      background: #ffffff;
      border: 1px solid rgba(0, 0, 0, 0.08);
    }

    .legend {
      display: flex;
      gap: 16px;
      font-size: 12px;
      color: var(--muted);
    }

    .legend span::before {
      content: "";
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 6px;
      background: currentColor;
    }

    .legend .pods { color: var(--accent-2); }
    .legend .all-nodes { color: var(--accent-3); }
    .legend .nodes { color: var(--accent); }

    .graph-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .graph-actions select,
    .graph-actions input[type=number] {
      max-width: 180px;
    }

        #timeRangeCustom,
    #timeRangeUnit {
      display: none;
    }

@keyframes rise {
      from { transform: translateY(16px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(6px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @media (max-width: 980px) {
      .grid-two { grid-template-columns: 1fr; }
      .summary-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }

    @media (max-width: 640px) {
      .summary-grid { grid-template-columns: 1fr; }
      .header { flex-direction: column; align-items: flex-start; }
    }
  </style>
</head>
<body>
  <div class="shell">
    <header class="header">
      <div>
        <div class="title">Scaleout Control</div>
        <p class="subtitle">Scale pod replicas and let autoscaler add nodes. Target max __MAX_PODS_PER_NODE__ pods per node.</p>
      </div>
      <div class="badge">Autoscaler-managed</div>
    </header>

    <section class="panel">
      <div class="tabs" role="tablist">
        <button class="tab active" data-tab="scale" role="tab">Set Pods</button>
        <button class="tab" data-tab="events" role="tab">Live Events</button>
        <button class="tab" data-tab="timing" role="tab">Timing</button>
        <button class="tab" data-tab="graph" role="tab">Scaling Graph</button>
      </div>

      <div id="tab-scale" class="tab-panel active" role="tabpanel">
        <div class="grid-two events-grid">
          <div class="card">
            <div class="card-title">Set desired pods</div>
            <div class="input-row">
              <label for="podsInput">Desired pods</label>
              <input id="podsInput" type="number" min="0" value="0" />
              <div class="button-row">
                <button id="scaleBtn" class="primary">Run scale</button>
                <button id="clearBtn" class="ghost">Reset run</button>
              </div>
            </div>
            <div class="meta" id="scaleHint">Ready to scale.</div>
          </div>
          <div class="card">
            <div class="card-title">Config snapshot</div>
            <div id="configPills"></div>
            <div id="derivedInfo" class="meta"></div>
          </div>
          <div class="card">
            <div class="card-title">Target deployment</div>
            <div class="input-row">
              <label for="targetSelect">Select deployment</label>
              <select id="targetSelect"></select>
            </div>
            <div class="meta" id="targetHint">Choose the workload to scale.</div>
          </div>
        </div>
      </div>

      <div id="tab-events" class="tab-panel" role="tabpanel">
        <div class="grid-two events-grid">
          <div class="card">
            <div class="card-title">Live event stream</div>
            <div id="logBox" class="log-box"></div>
          </div>
          <div class="card">
            <div class="card-title">Scaling events</div>
            <div class="event-tabs">
              <button class="event-tab active" data-event-tab="current">Current run</button>
              <button class="event-tab" data-event-tab="history">History</button>
              <button id="clearHistory" class="ghost">Clear history</button>
              <button id="exportEvents" class="ghost">Export events (CSV)</button>
            </div>
            <div class="table-wrap">
              <table class="event-table">
                <thead>
                  <tr>
                    <th>Event</th>
                    <th>Scheduled</th>
                    <th>Duration</th>
                    <th>Details</th>
                  </tr>
                </thead>
                <tbody id="eventsTable"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>

      <div id="tab-timing" class="tab-panel" role="tabpanel">
        <div class="summary-grid">
          <div class="summary-card">
            <div class="summary-label">Desired Pods</div>
            <div id="summaryDesiredPods" class="summary-value">—</div>
          </div>
          <div class="summary-card">
            <div class="summary-label">Worker Nodes</div>
            <div id="summaryExpectedNodes" class="summary-value">—</div>
          </div>
          <div class="summary-card">
            <div class="summary-label">All Nodes</div>
            <div id="summaryAllNodes" class="summary-value">—</div>
          </div>
          <div class="summary-card">
            <div class="summary-label">Pod Ready Time</div>
            <div id="summaryPodsReady" class="summary-value">—</div>
          </div>
          <div class="summary-card">
            <div class="summary-label">Node Ready Time</div>
            <div id="summaryNodesReady" class="summary-value">—</div>
          </div>
          <div class="summary-card">
            <div class="summary-label">Node Provision Time</div>
            <div id="summaryNodesProvision" class="summary-value">—</div>
          </div>
          <div class="summary-card">
            <div class="summary-label">Completion</div>
            <div id="summaryCompletion" class="summary-value">—</div>
          </div>
          <div class="summary-card">
            <div class="summary-label">Started</div>
            <div id="summaryStarted" class="summary-value">—</div>
          </div>
          <div class="summary-card">
            <div class="summary-label">Finished</div>
            <div id="summaryFinished" class="summary-value">—</div>
          </div>
        </div>
        <div class="timeline">
          <div class="timeline-title">Milestones</div>
          <div id="timelineList"></div>
        </div>
      </div>

      <div id="tab-graph" class="tab-panel" role="tabpanel">
        <div class="graph-wrap">
          <div class="graph-card">
            <canvas id="scaleChart"></canvas>
            <div class="legend" id="chartLegend"></div>
          </div>
          <div class="graph-actions">
            <label class="pill" for="timeRange">Time range</label>
            <select id="timeRange">
              <option value="all" selected>All</option>
              <option value="300">Last 5 min</option>
              <option value="600">Last 10 min</option>
              <option value="1800">Last 30 min</option>
              <option value="custom">Custom</option>
            </select>
            <input id="timeRangeCustom" type="number" min="1" step="1" value="5" aria-label="Custom time range value" />
            <select id="timeRangeUnit">
              <option value="sec" selected>sec</option>
              <option value="min">min</option>
              <option value="hr">hr</option>
            </select>
            <button id="exportChart" class="primary">Export graph (PNG)</button>
            <button id="refreshChart" class="ghost">Refresh graph</button>
          </div>
        </div>
      </div>
    </section>
  </div>

<script>
  const CONFIG = __CONFIG_JSON__;
  const logBox = document.getElementById('logBox');
  const podsInput = document.getElementById('podsInput');
  const scaleBtn = document.getElementById('scaleBtn');
  const clearBtn = document.getElementById('clearBtn');
  const configPills = document.getElementById('configPills');
  const derivedInfo = document.getElementById('derivedInfo');
  const scaleHint = document.getElementById('scaleHint');
  const targetSelect = document.getElementById('targetSelect');
  const targetHint = document.getElementById('targetHint');
  const tabs = Array.from(document.querySelectorAll('.tab'));
  const panels = Array.from(document.querySelectorAll('.tab-panel'));
  const summaryDesiredPods = document.getElementById('summaryDesiredPods');
  const summaryExpectedNodes = document.getElementById('summaryExpectedNodes');
  const summaryAllNodes = document.getElementById('summaryAllNodes');
  const summaryPodsReady = document.getElementById('summaryPodsReady');
  const summaryNodesReady = document.getElementById('summaryNodesReady');
  const summaryNodesProvision = document.getElementById('summaryNodesProvision');
  const summaryCompletion = document.getElementById('summaryCompletion');
  const summaryStarted = document.getElementById('summaryStarted');
  const summaryFinished = document.getElementById('summaryFinished');
  const timelineList = document.getElementById('timelineList');

  const chartLegend = document.getElementById('chartLegend');

  function renderLegend(showAllNodes) {
    if (!chartLegend) return;
    chartLegend.innerHTML = '';
    const nodesSpan = document.createElement('span');
    nodesSpan.className = 'nodes';
    nodesSpan.textContent = 'Worker nodes ready';
    chartLegend.appendChild(nodesSpan);

    if (showAllNodes) {
      const allSpan = document.createElement('span');
      allSpan.className = 'all-nodes';
      allSpan.textContent = 'All nodes ready';
      chartLegend.appendChild(allSpan);
    }

    const podsSpan = document.createElement('span');
    podsSpan.className = 'pods';
    podsSpan.textContent = 'Pods ready';
    chartLegend.appendChild(podsSpan);
  }

  const chartCanvas = document.getElementById('scaleChart');
  const exportChart = document.getElementById('exportChart');
  const refreshChart = document.getElementById('refreshChart');
  const timeRange = document.getElementById('timeRange');
  const timeRangeCustom = document.getElementById('timeRangeCustom');
  const timeRangeUnit = document.getElementById('timeRangeUnit');
  const eventsTable = document.getElementById('eventsTable');
  const exportEvents = document.getElementById('exportEvents');
  const clearHistory = document.getElementById('clearHistory');
  const eventTabs = Array.from(document.querySelectorAll('.event-tab'));
  let eventSource = null;
  let sseDone = false;
  let sseJobId = null;

  const eventHistory = [];
  let currentRunRows = [];
  let activeEventTab = 'current';

  function renderEventsTable() {
    if (!eventsTable) return;
    eventsTable.innerHTML = '';
    const rows = activeEventTab === 'history'
      ? eventHistory.flatMap((run) => run.rows)
      : currentRunRows;
    rows.forEach((row) => eventsTable.appendChild(row.cloneNode(true)));
  }

  function appendEventToTable(row) {
    if (!eventsTable) return;
    if (activeEventTab !== 'current') return;
    eventsTable.appendChild(row.cloneNode(true));
  }

  function setEventTab(tab) {
    activeEventTab = tab;
    eventTabs.forEach((btn) => btn.classList.toggle('active', btn.dataset.eventTab === tab));
    renderEventsTable();
  }

  const state = {
    logs: [],
    startTimeMs: null,
    endTimeMs: null,
    expectedNodes: null,
    allNodes: null,
    desiredPods: null,
    statusSamples: [],
    seenScaleRequest: false,
    lastStatusKey: null,
    milestones: {
      nodeProvision: null,
      nodeReady: null,
      podReady: null,
    }
  };

  function setTab(tabName) {
    tabs.forEach((tab) => tab.classList.toggle('active', tab.dataset.tab === tabName));
    panels.forEach((panel) => panel.classList.toggle('active', panel.id === 'tab-' + tabName));
  }

  tabs.forEach((tab) => {
    tab.addEventListener('click', () => setTab(tab.dataset.tab));
  });

  let autoScrollLogs = true;
  let lastLogLine = null;

  function addLog(line) {
    if (line === lastLogLine) {
      return;
    }
    lastLogLine = line;
    state.logs.push(line);
    const div = document.createElement('div');
    div.className = 'log-line';
    div.textContent = line;
    logBox.appendChild(div);
    if (autoScrollLogs) {
      logBox.scrollTop = logBox.scrollHeight;
    }
    parseLogLine(line);
  }

  function resetMetrics(preserveLog) {
    if (!preserveLog) {
      state.logs = [];
      logBox.innerHTML = '';
    }
    if (eventsTable) {
      eventsTable.innerHTML = '';
    }
    state.startTimeMs = null;
    state.endTimeMs = null;
    state.expectedNodes = null;
    state.desiredPods = null;
    state.statusSamples = [];
    state.lastStatusKey = null;
    state.milestones = { nodeProvision: null, nodeReady: null, podReady: null };
    updateSummary();
    drawChart();
    scaleHint.textContent = 'Ready to scale.';
  }



  async function syncTargetReplicas(namespace, deployment) {
    if (!namespace || !deployment) return;
    try {
      const res = await fetch(`/api/deployment?namespace=${encodeURIComponent(namespace)}&name=${encodeURIComponent(deployment)}`);
      if (!res.ok) return;
      const data = await res.json();
      if (typeof data.replicas === 'number') {
        podsInput.value = data.replicas;
        setDerived();
      }
    } catch (err) {
      // ignore
    }
  }

  async function loadDeployments() {
    if (!targetSelect) return;
    const current = CONFIG.targetNamespace + '/' + CONFIG.targetDeployment;
    const fallbackOption = () => {
      targetSelect.innerHTML = '';
      const opt = document.createElement('option');
      opt.value = current;
      opt.textContent = current;
      targetSelect.appendChild(opt);
      targetSelect.value = current;
      syncTargetReplicas(CONFIG.targetNamespace, CONFIG.targetDeployment);
    };

    try {
      const res = await fetch('/api/deployments');
      if (!res.ok) {
        targetHint.textContent = 'Failed to load deployments.';
        fallbackOption();
        return;
      }
      const data = await res.json();
      targetSelect.innerHTML = '';
      const items = data.items || [];
      items.forEach((item) => {
        const opt = document.createElement('option');
        opt.value = item.namespace + '/' + item.name;
        opt.textContent = item.namespace + '/' + item.name;
        targetSelect.appendChild(opt);
      });
      const match = items.find((i) => i.namespace + '/' + i.name === current);
      if (match) {
        targetSelect.value = current;
      } else if (items.length) {
        targetSelect.value = items[0].namespace + '/' + items[0].name;
      }
      if (targetSelect.value) {
        const parts = targetSelect.value.split('/');
        if (parts.length === 2) {
          CONFIG.targetNamespace = parts[0];
          CONFIG.targetDeployment = parts[1];
        }
        renderConfig();
        syncTargetReplicas(CONFIG.targetNamespace, CONFIG.targetDeployment);
      }
      if (!items.length) {
        targetHint.textContent = 'No deployments found (K8s disabled).';
      }
    } catch (err) {
      targetHint.textContent = 'Failed to load deployments.';
      fallbackOption();
    }
  }

  async function updateTarget(value) {
    if (!value) return;
    const parts = value.split('/');
    if (parts.length !== 2) return;
    const [namespace, deployment] = parts;
    try {
      const res = await fetch('/api/target', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ namespace, deployment })
      });
      if (!res.ok) {
        targetHint.textContent = 'Failed to update target.';
        return;
      }
      CONFIG.targetNamespace = namespace;
      CONFIG.targetDeployment = deployment;
      targetHint.textContent = 'Target set to ' + namespace + '/' + deployment + '.';
      renderConfig();
      syncTargetReplicas(namespace, deployment);
    } catch (err) {
      targetHint.textContent = 'Failed to update target.';
    }
  }

  function setDerived() {
    const pods = parseInt(podsInput.value || '0', 10);
    derivedInfo.textContent = 'Max pods per node: ' + CONFIG.maxPodsPerNode;
  }

  function renderConfig() {
    const items = [
      'namespace: ' + CONFIG.targetNamespace,
      'deployment: ' + CONFIG.targetDeployment,
      CONFIG.nodeSelector ? 'node selector: ' + CONFIG.nodeSelector : 'node selector: auto',
      'max pods per node: ' + CONFIG.maxPodsPerNode,
    ];
    configPills.innerHTML = '';
    items.forEach((item) => {
      const span = document.createElement('span');
      span.className = 'pill';
      span.textContent = item;
      configPills.appendChild(span);
    });
  }

  function formatDuration(value) {
    if (value === null || value === undefined) return '—';
    return value.toFixed(1) + 's';
  }

  function formatTime(value) {
    if (!value) return '—';
    const date = new Date(value);
    return date.toLocaleTimeString();
  }

  function updateTimeline() {
    const items = [];
    if (state.milestones.nodeProvision !== null) {
      items.push('Node objects seen in ' + formatDuration(state.milestones.nodeProvision));
    }
    if (state.milestones.nodeReady !== null) {
      items.push('Worker nodes ready in ' + formatDuration(state.milestones.nodeReady));
    }
    if (state.milestones.podReady !== null) {
      items.push('Pods ready in ' + formatDuration(state.milestones.podReady));
    }
    if (!items.length) {
      items.push('No milestones recorded yet.');
    }
    timelineList.innerHTML = '';
    items.forEach((text) => {
      const div = document.createElement('div');
      div.className = 'timeline-item';
      div.textContent = text;
      timelineList.appendChild(div);
    });
  }

  function appendEventRow(event, scheduledAt, duration, details, isoTime, data, epochMs) {
    if (!eventsTable) return;
    const row = document.createElement('tr');
    if (isoTime) {
      row.dataset.iso = isoTime;
    }
    if (epochMs !== null && epochMs !== undefined) {
      row.dataset.epoch = String(epochMs);
    }
    if (data && typeof data === 'object') {
      row.dataset.payload = JSON.stringify(data);
    }
    const cols = [event, scheduledAt, duration, details];
    cols.forEach((value) => {
      const td = document.createElement('td');
      td.textContent = value;
      row.appendChild(td);
    });
    currentRunRows.push(row);
    appendEventToTable(row);
  }

  function updateSummary() {
    summaryDesiredPods.textContent = state.desiredPods !== null ? state.desiredPods : '—';
    summaryExpectedNodes.textContent = state.expectedNodes !== null ? state.expectedNodes : '—';
    summaryAllNodes.textContent = state.allNodes !== null ? state.allNodes : '—';
    const allNodesCard = summaryAllNodes?.closest('.summary-card');
    if (allNodesCard) {
      const hideAllNodes = (state.allNodes === null || state.expectedNodes === null)
        || (state.allNodes === state.expectedNodes);
      allNodesCard.style.display = hideAllNodes ? 'none' : '';
    }
    summaryPodsReady.textContent = formatDuration(state.milestones.podReady);
    summaryNodesReady.textContent = formatDuration(state.milestones.nodeReady);
    summaryNodesProvision.textContent = formatDuration(state.milestones.nodeProvision);
    summaryCompletion.textContent = formatDuration(state.milestones.podReady);
    summaryStarted.textContent = formatTime(state.startTimeMs);
    summaryFinished.textContent = formatTime(state.endTimeMs);
    updateTimeline();
  }

  function recordStatusSample(ts, nodesReady, podsReady, expectedNodes, desiredPods, allNodes, allReady) {
    if (!state.startTimeMs) {
      state.startTimeMs = ts;
    }
    state.statusSamples.push({
      t: ts,
      nodesReady,
      podsReady,
      expectedNodes,
      desiredPods,
      allNodes,
      allReady,
    });
    drawChart();
  }

  function parseLogLine(line) {
    const parts = line.split(' | ');
    if (parts.length < 2) return;
    const ts = Date.parse(parts[0]);
    const message = parts.slice(1).join(' | ');
    const scheduledAt = Number.isFinite(ts) ? formatTime(ts) : '—';

    if (message.startsWith('Scale request received')) {
      if (state.seenScaleRequest) {
        return;
      }
      if (currentRunRows.length) {
        eventHistory.unshift({ startedAt: state.startTimeMs, rows: currentRunRows });
      }
      currentRunRows = [];
      state.seenScaleRequest = true;
      resetMetrics(true);
      renderEventsTable();
      state.startTimeMs = Number.isFinite(ts) ? ts : Date.now();
      const match = message.match(/pods=(\d+)/);
      if (match) {
        state.desiredPods = parseInt(match[1], 10);
      }
      scaleHint.textContent = 'Scale job started at ' + formatTime(state.startTimeMs) + '.';
      appendEventRow('Scale request', scheduledAt, '—', 'Pods=' + state.desiredPods, new Date(ts).toISOString(), { pods: state.desiredPods, expectedNodes: state.expectedNodes }, Number.isFinite(ts) ? ts : null);
      updateSummary();
    }

    if (message.startsWith('Target deployment')) {
      const match = message.match(/->\s*(\d+)\s*replicas/);
      if (match) {
        state.desiredPods = parseInt(match[1], 10);
        updateSummary();
      }
    }

    const statusMatch = message.match(/Status: nodes (\d+) \(ready (\d+)\)(?:; all nodes: (\d+) \(ready (\d+)\))? \| pods ready (\d+)\/(\d+)/);
    if (statusMatch) {
      const nodesTotal = parseInt(statusMatch[1], 10);
      const nodesReady = parseInt(statusMatch[2], 10);
      const allTotal = statusMatch[3] ? parseInt(statusMatch[3], 10) : null;
      const allReady = statusMatch[4] ? parseInt(statusMatch[4], 10) : null;
      const podsReady = parseInt(statusMatch[5], 10);
      const desiredPods = parseInt(statusMatch[6], 10);
      state.expectedNodes = nodesTotal;
      state.allNodes = allTotal;
      state.desiredPods = desiredPods;
      recordStatusSample(Number.isFinite(ts) ? ts : Date.now(), nodesReady, podsReady, nodesTotal, desiredPods, allTotal, allReady);
      const elapsed = state.startTimeMs ? ((Number.isFinite(ts) ? ts : Date.now()) - state.startTimeMs) / 1000 : null;
      const statusKey = nodesTotal + ':' + (allTotal || 0) + ':' + podsReady + ':' + desiredPods;
      if (state.lastStatusKey !== statusKey) {
        state.lastStatusKey = statusKey;
        appendEventRow('Status', scheduledAt, formatDuration(elapsed), 'nodes ready ' + nodesReady + ' / total ' + nodesTotal + (allTotal !== null ? (', all nodes ' + allTotal) : '') + ', pods ready ' + podsReady + '/' + desiredPods, new Date(ts).toISOString(), { nodesTotal, nodesReady, allTotal, allReady, podsReady, desiredPods, elapsedSec: elapsed }, Number.isFinite(ts) ? ts : null);
      }
    }

    const autoscalerMatch = message.match(/Autoscaler triggered scale-up at (.+) UTC/);
    if (autoscalerMatch) {
      appendEventRow('Autoscaler trigger', scheduledAt, '—', 'Scale-up triggered', new Date(ts).toISOString(), { triggerTime: autoscalerMatch[1] }, Number.isFinite(ts) ? ts : null);
      updateSummary();
    }

    const nodeObjMatch = message.match(/First new node object at (.+) UTC/);
    if (nodeObjMatch) {
      appendEventRow('Node object', scheduledAt, '—', 'First new node object', new Date(ts).toISOString(), { nodeObjectTime: nodeObjMatch[1] }, Number.isFinite(ts) ? ts : null);
      updateSummary();
    }

    const provisionStartMatch = message.match(/Node provisioning started \((.+)\)\./);
    if (provisionStartMatch) {
      appendEventRow('Provision start', scheduledAt, '—', provisionStartMatch[1], new Date(ts).toISOString(), { source: provisionStartMatch[1] }, Number.isFinite(ts) ? ts : null);
      updateSummary();
    }

    const provisionMatch = message.match(/Node provisioning time.*?: ([\d.]+)s/);
    if (provisionMatch) {
      state.milestones.nodeProvision = parseFloat(provisionMatch[1]);
      appendEventRow('Node provision', scheduledAt, formatDuration(state.milestones.nodeProvision), 'Node objects seen', new Date(ts).toISOString(), { nodeProvisionSec: state.milestones.nodeProvision }, Number.isFinite(ts) ? ts : null);
      updateSummary();
    }

    const nodeReadyIncrease = message.match(/Worker nodes Ready (increased|changed) to (\d+) in ([\d.]+)s/);
    if (nodeReadyIncrease) {
      const action = nodeReadyIncrease[1];
      const readyCount = parseInt(nodeReadyIncrease[2], 10);
      const elapsedSec = parseFloat(nodeReadyIncrease[3]);
      appendEventRow('Nodes ready', scheduledAt, elapsedSec + 's', 'Ready nodes: ' + readyCount + ' (' + action + ')', new Date(ts).toISOString(), { readyNodes: readyCount, action, elapsedSec }, Number.isFinite(ts) ? ts : null);
      updateSummary();
    }

    const nodeReadyMatch = message.match(/Node ready time: ([\d.]+)s/);
    if (nodeReadyMatch) {
      state.milestones.nodeReady = parseFloat(nodeReadyMatch[1]);
      appendEventRow('Node ready', scheduledAt, formatDuration(state.milestones.nodeReady), 'Worker nodes ready', new Date(ts).toISOString(), { nodeReadySec: state.milestones.nodeReady }, Number.isFinite(ts) ? ts : null);
      updateSummary();
    }

    const podReadyMatch = message.match(/Pod readiness time: ([\d.]+)s/);
    if (podReadyMatch) {
      state.milestones.podReady = parseFloat(podReadyMatch[1]);
      state.endTimeMs = state.startTimeMs ? state.startTimeMs + state.milestones.podReady * 1000 : Date.now();
      appendEventRow('Pods ready', scheduledAt, formatDuration(state.milestones.podReady), 'Pods reached Ready', new Date(ts).toISOString(), { podsReadySec: state.milestones.podReady, pods: state.desiredPods }, Number.isFinite(ts) ? ts : null);
      updateSummary();
    }
  }

  function updateTimeRangeControls() {
    if (!timeRange) return;
    const isCustom = timeRange.value === 'custom';
    timeRangeCustom.style.display = isCustom ? 'inline-block' : 'none';
    timeRangeUnit.style.display = isCustom ? 'inline-block' : 'none';
    if (!isCustom && timeRange.value !== 'all') {
      const valueSec = parseInt(timeRange.value, 10);
      timeRangeCustom.value = Number.isFinite(valueSec) ? Math.round(valueSec / 60) : 5;
      timeRangeUnit.value = 'min';
    }
    drawChart();
  }

  function drawChart() {
    const ctx = chartCanvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const width = chartCanvas.clientWidth || 600;
    const height = chartCanvas.clientHeight || 320;
    chartCanvas.width = width * dpr;
    chartCanvas.height = height * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.clearRect(0, 0, width, height);

    if (!state.statusSamples.length) {
      ctx.fillStyle = '#a5a29f';
      ctx.font = '14px "Avenir Next", sans-serif';
      ctx.fillText('Waiting for status samples to draw the chart...', 16, 28);
      renderLegend(false);
      return;
    }

    const start = state.startTimeMs || state.statusSamples[0].t;
    const samples = state.statusSamples.map((sample) => ({
      t: (sample.t - start) / 1000,
      nodesReady: sample.nodesReady,
      podsReady: sample.podsReady,
      allNodesReady: sample.allReady,
    }));

    const maxTime = Math.max(...samples.map((s) => s.t), 1);
    let rangeSec = maxTime;
    if (timeRange && timeRange.value !== 'all') {
      if (timeRange.value === 'custom') {
        const customValue = parseFloat(timeRangeCustom.value || '0');
        const unit = timeRangeUnit ? timeRangeUnit.value : 'sec';
        const multiplier = unit === 'hr' ? 3600 : unit === 'min' ? 60 : 1;
        rangeSec = Number.isFinite(customValue) && customValue > 0 ? customValue * multiplier : maxTime;
      } else {
        const preset = parseInt(timeRange.value, 10);
        rangeSec = Number.isFinite(preset) && preset > 0 ? preset : maxTime;
      }
    }
    rangeSec = Math.max(10, Math.min(rangeSec, maxTime));

    const windowStart = Math.max(0, maxTime - rangeSec);
    const windowSamples = samples
      .filter((s) => s.t >= windowStart)
      .sort((a, b) => a.t - b.t)
      .filter((s, idx, arr) => idx === 0 || s.t !== arr[idx - 1].t);

    if (windowSamples.length === 0) {
      ctx.fillStyle = '#a5a29f';
      ctx.font = '14px "Avenir Next", sans-serif';
      ctx.fillText('Waiting for status samples to draw the chart...', 16, 28);
      renderLegend(false);
      return;
    }

    if (windowSamples.length === 1) {
      const single = windowSamples[0];
      const showAllNodes = single.allNodesReady !== undefined
        && single.allNodesReady !== null
        && single.allNodesReady !== single.nodesReady;
      const padding = { left: 92, right: 18, top: 18, bottom: 44 };
      const chartW = width - padding.left - padding.right;
      const chartH = height - padding.top - padding.bottom;
      const maxValue = Math.max(single.podsReady, single.nodesReady, 1);

      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = padding.top + (chartH / 4) * i;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
      }

      ctx.fillStyle = '#8a8077';
      ctx.font = '12px "Avenir Next", sans-serif';
      ctx.fillText('0s', padding.left, height - 10);
      ctx.fillText(String(maxValue), 10, padding.top + 8);

      const x = padding.left + chartW * 0.5;
      const yNodes = padding.top + chartH - (single.nodesReady / maxValue) * chartH;
      const yPods = padding.top + chartH - (single.podsReady / maxValue) * chartH;

      ctx.fillStyle = '#0f6d5b';
      ctx.beginPath();
      ctx.arc(x, yNodes, 4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = '#e36d2f';
      ctx.beginPath();
      ctx.arc(x, yPods, 4, 0, Math.PI * 2);
      ctx.fill();

      renderLegend(showAllNodes);
      return;
    }

    const maxValueRaw = Math.max(
      1,
      ...windowSamples.map((s) => s.podsReady),
      ...windowSamples.map((s) => s.nodesReady),
      ...windowSamples.map((s) => s.allNodesReady || 0)
    );

    function niceMax(value) {
      const magnitude = Math.pow(10, Math.floor(Math.log10(value)));
      const scaled = value / magnitude;
      let nice = 1;
      if (scaled > 5) nice = 10;
      else if (scaled > 2) nice = 5;
      else if (scaled > 1) nice = 2;
      return nice * magnitude;
    }

    const maxValue = niceMax(maxValueRaw);

    const padding = { left: 92, right: 18, top: 18, bottom: 44 };
    const chartW = width - padding.left - padding.right;
    const chartH = height - padding.top - padding.bottom;

    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 1;
    const yTicks = 5;
    for (let i = 0; i <= yTicks; i++) {
      const y = padding.top + (chartH / yTicks) * i;
      ctx.beginPath();
      ctx.moveTo(padding.left, y);
      ctx.lineTo(width - padding.right, y);
      ctx.stroke();
    }

    ctx.fillStyle = '#8a8077';
    ctx.font = '12px "Avenir Next", sans-serif';
    for (let i = 0; i <= yTicks; i++) {
      const value = Math.round((maxValue / yTicks) * (yTicks - i));
      const y = padding.top + (chartH / yTicks) * i + 4;
      ctx.fillText(String(value), 28, y);
    }

    const xTicks = 5;
    for (let i = 0; i <= xTicks; i++) {
      const t = windowStart + (rangeSec / xTicks) * i;
      const x = padding.left + ((t - windowStart) / rangeSec) * chartW;
      ctx.beginPath();
      ctx.moveTo(x, padding.top + chartH);
      ctx.lineTo(x, padding.top + chartH + 6);
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.stroke();
      ctx.fillStyle = '#8a8077';
      ctx.fillText(t.toFixed(0) + 's', x - 10, height - 10);
    }

    ctx.save();
    ctx.fillStyle = '#6c625a';
    ctx.font = '12px "Avenir Next", sans-serif';
    ctx.fillText('Time (s)', padding.left + chartW / 2 - 20, height - 4);
    ctx.translate(18, padding.top + chartH / 2 + 24);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Ready count', 0, 0);
    ctx.restore();

    function drawLine(color, key) {
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      windowSamples.forEach((sample, index) => {
        const x = padding.left + ((sample.t - windowStart) / rangeSec) * chartW;
        const y = padding.top + chartH - (sample[key] / maxValue) * chartH;
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
    }

    drawLine('#0f6d5b', 'nodesReady');
    const showAllNodes = windowSamples.some((s) => s.allNodesReady !== undefined && s.allNodesReady !== null && s.allNodesReady !== s.nodesReady);
    if (showAllNodes) {
      ctx.setLineDash([6, 4]);
      drawLine('#1f7dcf', 'allNodesReady');
      ctx.setLineDash([]);
    }
    drawLine('#e36d2f', 'podsReady');
    renderLegend(showAllNodes);
  }

  async function startScale() {
    state.seenScaleRequest = false;
    resetMetrics(false);
    const pods = parseInt(podsInput.value || '0', 10);
    if (Number.isNaN(pods) || pods < 0) {
      addLog('Invalid pod count.');
      return;
    }
    setDerived();
    addLog('Submitting scale request for ' + pods + ' pods...');
    try {
      const response = await fetch('/api/scale', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          pods,
          namespace: CONFIG.targetNamespace,
          deployment: CONFIG.targetDeployment
        })
      });
      if (!response.ok) {
        const err = await response.json();
        addLog('Scale request failed: ' + (err.detail || response.statusText));
        return;
      }
      const data = await response.json();
      if (eventSource) {
        eventSource.close();
      }
      sseDone = false;
      sseJobId = data.jobId;
      eventSource = new EventSource('/api/stream/' + data.jobId);
      eventSource.onmessage = (event) => addLog(event.data);
      eventSource.addEventListener('done', () => {
        sseDone = true;
        addLog('Log stream closed.');
        if (eventSource) {
          eventSource.close();
        }
      });
      eventSource.onerror = () => {
        if (!sseDone) {
          addLog('Log stream error. Reconnecting...');
        }
      };
    } catch (err) {
      addLog('Scale request error: ' + err);
    }
  }

  function exportEventsCsv() {
    if (!eventsTable) return;
    const rows = [['Event', 'Scheduled', 'Scheduled ISO', 'Scheduled Epoch Ms', 'Duration', 'Details', 'Data']];
    Array.from(eventsTable.querySelectorAll('tr')).forEach((row) => {
      const cells = Array.from(row.querySelectorAll('td')).map((cell) => cell.textContent || '');
      const iso = row.dataset.iso || '';
      const epoch = row.dataset.epoch || '';
      const payload = row.dataset.payload || '';
      if (cells.length) rows.push([cells[0], cells[1], iso, epoch, cells[2], cells[3], payload]);
    });
    const csv = rows
      .map((row) => row.map((v) => '"' + String(v).replace(/"/g, '""') + '"').join(','))
      .join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'scaleout-events.csv';
    link.click();
    URL.revokeObjectURL(link.href);
  }

  function exportGraph() {
    const link = document.createElement('a');
    link.download = 'scaleout-graph.png';
    link.href = chartCanvas.toDataURL('image/png');
    link.click();
  }

  logBox.addEventListener('scroll', () => {
    const nearBottom = logBox.scrollTop + logBox.clientHeight >= logBox.scrollHeight - 8;
    autoScrollLogs = nearBottom;
  });

  scaleBtn.addEventListener('click', startScale);
  clearBtn.addEventListener('click', () => resetMetrics(false));
  podsInput.addEventListener('input', setDerived);
  exportChart.addEventListener('click', exportGraph);
  refreshChart.addEventListener('click', drawChart);
  if (targetSelect) {
    targetSelect.addEventListener('change', (event) => updateTarget(event.target.value));
  }
  window.addEventListener('resize', drawChart);
  if (timeRange) {
    timeRange.addEventListener('change', updateTimeRangeControls);
  }
  if (timeRangeCustom) {
    timeRangeCustom.addEventListener('input', drawChart);
  }
  if (timeRangeUnit) {
    timeRangeUnit.addEventListener('change', drawChart);
  }
  if (exportEvents) {
    exportEvents.addEventListener('click', exportEventsCsv);
  }
  if (clearHistory) {
    clearHistory.addEventListener('click', () => {
      eventHistory.length = 0;
      if (activeEventTab === 'history') {
        renderEventsTable();
      }
    });
  }
  if (eventTabs.length) {
    eventTabs.forEach((btn) => {
      btn.addEventListener('click', () => setEventTab(btn.dataset.eventTab));
    });
  }

  updateTimeRangeControls();
  renderConfig();
  loadDeployments();
  setEventTab('current');
  setDerived();
  updateSummary();
  drawChart();
</script>
</body>
</html>
